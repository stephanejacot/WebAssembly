<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="article.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    <link rel="icon" type="image/xpng" href="./images/WebAssembly_Logo.png">
    <title>WebAssembly</title>
</head>

<body>

    <header>
        <nav class="navbar sticky-top navbar-expand-lg navbar-light bg-light">
            <img src="./images/WebAssembly_Logo.png" class= "logo" alt="logo">
            <a class="navbar-brand" href="https://webassembly.org/">WebAssembly</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav mr-auto">
                    <li class="nav-item active">
                        <a class="nav-link" href="#">Accueil <span class="sr-only">(current)</span></a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#">Actus</a>
                    </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">A Propos</a>
                        </li>
                    </ul>
                    <form class="form-inline my-2 my-lg-0">
                        <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">
                        <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
                    </form>
                </div>               
            </nav>
        </header>

        <nav aria-label="breadcrumb">
            <ol class="breadcrumb fil">
                <li class="breadcrumb-item"><a href="#" class="fil">Home</a></li>
                <li class="breadcrumb-item active" aria-current="page"> Actus</li>
            </ol>
        </nav>
        <div class="title-page text-center">
            <h1> Improving WebAssembly performance in browsers </h1>
        </div>
        <div class="row">
            <div> <img src="./images/WebAssembly-Explained.jpg" class="img-backg col-8 offset-2"> </div>
                <div class="col-6 offset-3">
                    <div class="text-justify">
                        <p> 
                            Some speed improvements will come as browsers improve WebAssembly support in their engines. The browser vendors are working on these issues independently.
                            <h3>Faster function calls between JS and WebAssembly </h3>
                            Currently, calling a WebAssembly function in JS code is slower than it needs to be. That’s because it has to do something called “trampolining”. The JIT doesn’t know how to deal directly with WebAssembly, so it has to route the WebAssembly to something that does. This is a slow piece of code in the engine itself, which does setup to run the optimized WebAssembly code.
                            This can be up to 100x slower than it would be if the JIT knew how to handle it directly.
                            You won’t notice this overhead if you’re passing a single large task off to the WebAssembly module. But if you have lots of back-and-forth between WebAssembly and JS (as you do with smaller tasks), then this overhead is noticeable.
                        </p>
                        <p>
                            <h3>Faster load time</h3>
                            JITs have to manage the tradeoff between faster load times and faster execution times. If you spend more time compiling and optimizing ahead of time, that speeds up execution, but it slows down start up.
                            There’s a lot of ongoing work to balance up-front compilation (which ensures there is no jank once the code starts running) and the basic fact that most parts of the code won’t be run enough times to make optimization worth it.
                            Since WebAssembly doesn’t need to speculate what types will be used, the engines don’t have to worry about monitoring the types at runtime. This gives them more options, for example parallelizing compilation work with execution.
                            Plus, recent additions to the JavaScript API will allow streaming compilation of WebAssembly. This means that the engine can start compiling while bytes are still being downloaded.
                            In Firefox we’re working on a two-compiler system. One compiler will run ahead of time and do a pretty good job at optimizing the code. While that’s running code, another compiler will do a full optimization in the background. The fully-optimized version of the code will be swapped in when it’s ready.
                        </p>
                        <p>
                            <h3>Adding post-MVP features to the spec</h3>
                            One of the goals of WebAssembly is to specify in small chunks and test along the way, rather than designing everything up front.
                            This means there are lots of features that are expected, but haven’t been 100% thought-through yet. They will have to go through the specification process, which all of the browser vendors are active in.
                            These features are called future features. Here are just a few.
                        </p>
                        <p>
                            <h3>Working directly with the DOM </h3>
                            Currently, there’s no way to interact with the DOM. This means you can’t do something like element.innerHTML to update a node from WebAssembly.
                            Instead, you have to go through JS to set the value. This can mean passing a value back to the JavaScript caller. On the other hand, it can mean calling a JavaScript function from within WebAssembly—both JavaScript and WebAssembly functions can be used as imports in a WebAssembly module.
                        </p>
                        <p>
                            Either way, it is likely that going through JavaScript is slower than direct access would be. Some applications of WebAssembly may be held up until this is resolved.
                            <h3> Shared memory concurrency </h3>
                            One way to speed up code is to make it possible for different parts of the code to run at the same time, in parallel. This can sometimes backfire, though, since the overhead of communication between threads can take up more time than the task would have in the first place.
                            But if you can share memory between threads, it reduces this overhead. To do this, WebAssembly will use JavaScript’s new SharedArrayBuffer. Once that is in place in the browsers, the working group can start specifying how WebAssembly should work with them.
                        <p>
                            <h3>SIMD</h3>
                            If you read other posts or watch talks about WebAssembly, you may hear about SIMD support. The acronym stands for single instruction, multiple data. It’s another way of running things in parallel.
                            SIMD makes it possible to take a large data structure, like a vector of different numbers, and apply the same instruction to different parts at the same time. In this way, it can drastically speed up the kinds of complex computations you need for games or VR.
                            This is not too important for the average web app developer. But it is very important to developers working with multimedia, such as game developers.
                        </p>
                        <p>
                            <h3>Exception handling</h3>
                            Many code bases in languages like C++ use exceptions. However, exceptions aren’t yet specified as part of WebAssembly.
                            If you are compiling your code with Emscripten, it will emulate exception handling for some compiler optimization levels. This is pretty slow, though, so you may want to use the DISABLE_EXCEPTION_CATCHING flag to turn it off.
                            Once exceptions are handled natively in WebAssembly, this emulation won’t be necessary.
                        </p>
                        <p>
                            <h3>Other improvements—making things easier for developers</h3>
                            Some future features don’t affect performance, but will make it easier for developers to work with WebAssembly.
                                First-class source-level developer tools. Currently, debugging WebAssembly in the browser is like debugging raw assembly. Very few developers can mentally map their source code to assembly, though. We’re looking at how we can improve tooling support so that developers can debug their source code.
                                Garbage collection. If you can define your types ahead of time, you should be able to turn your code into WebAssembly. So code using something like TypeScript should be compilable to WebAssembly. The only hitch currently, though, is that WebAssembly doesn’t know how to interact with existing garbage collectors, like the one built in to the JS engine. The idea of this future feature is to give WebAssembly first-class access to the builtin GC with a set of low-level GC primitive types and operations.
                                ES6 Module integration. Browsers are currently adding support for loading JavaScript modules using the script tag. Once this feature is added.
                        </p>
                    </div>
                </div>
            </div>
        </div>

    <footer class="bg-light ">
        <div class="container-fluid">
            <div class="row ">
                <nav class="nav flex-column offset-2">
                    <a class="nav-link" href="#">A propos</a>
                    <a class="nav-link" href="#">Nous contacter</a>
                </nav>
                <nav class="nav flex-column offset-2">
                    <a class="nav-link" href="#">WebAssembly</a>
                    <a class="nav-link" href="#">Mentions légales</a>
                </nav>
                <nav class="nav flex-column offset-2">
                    <a class="nav-link" href="#"><i class="fab fa-facebook-square"></i>Facebook</a>
                    <a class="nav-link" href="https://github.com/webassembly"><i class="fab fa-github"></i>Github</a>
                </nav>
            </div>
        </div>
    </footer>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>   
</body>
</html>
